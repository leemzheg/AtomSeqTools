SAMPLES = config['samples']

rule all:
    input:
            expand('{sample}/{sample}_basic_summary.xls',sample=SAMPLES)

rule fastp_pe:
    input:  fq1 = lambda wildcards: f"{config['samples'][wildcards.sample]['directory']}/{config['samples'][wildcards.sample]['prefix']}{config['samples'][wildcards.sample]['R1_suffix']}",
            fq2 = lambda wildcards: f"{config['samples'][wildcards.sample]['directory']}/{config['samples'][wildcards.sample]['prefix']}{config['samples'][wildcards.sample]['R2_suffix']}"
    output: qc_fq1 = '{sample}/Mid-files/01_CleanFqMeth_1.fq.gz',
            qc_fq2 = '{sample}/Mid-files/01_CleanFqMeth_2.fq.gz',
            html = '{sample}/Mid-files/01_CleanFqMeth.html',
            json = '{sample}/Mid-files/01_CleanFqMeth.json'
    log:    #stdout = '{sample}/logs/01_fastp.stdout',
            stderr = '{sample}/logs/01_fastp.stderr',
    params: fastp = config['fastp']['path'],
            read_num = config['fastp']['read_to_process'],
            adapter1 = config['fastp']['adapter_r1'],
            adapter2 = config['fastp']['adapter_r2']
    threads:config['fastp']['threads']
    shell:
            '{params.fastp} -i {input.fq1} -o {output.qc_fq1} '
            '-I {input.fq2} -O {output.qc_fq2} '
            '--adapter_sequence {params.adapter1} '
            '--adapter_sequence_r2 {params.adapter2} '
            '--correction --fix_mgi_id --cut_tail '
            '-l 30 --overlap_len_require 10 -w {threads} '
            '--reads_to_process {params.read_num} '
            '-j {output.json} -h {output.html} '
            '2>{log.stderr}\n'

rule add_UMI:
    input:
        fq1 = '{sample}/Mid-files/01_CleanFqMeth_1.fq.gz',
        fq2 = '{sample}/Mid-files/01_CleanFqMeth_2.fq.gz'
    output:
        umi1 = '{sample}/Mid-files/02_FqWithUmiMeth_1.fq.gz',
        umi2 = '{sample}/Mid-files/02_FqWithUmiMeth_2.fq.gz'
    run:
        import gzip
        a = 0
        a = 0
        with gzip.open(output.umi1, "wt", compresslevel=4) as fq1_output:
            with gzip.open(output.umi2, "wt", compresslevel=4) as fq2_output:
                with gzip.open(input.fq1, "rt") as handle1:
                    with gzip.open(input.fq2, "rt") as handle2:
                        for tu in zip(handle1, handle2):
                                a += 1
                                if a % 4 == 1:
                                        title1 = tu[0].split()[0]
                                        title2 = tu[1].split()[0]
                                if a % 4 == 2:
                                        tmp_umi = ":UMI_" + tu[1][:20]
                                        fq1_output.write(title1 + tmp_umi + "\n")
                                        fq1_output.write(tu[0])
                                        fq2_output.write(title2 + tmp_umi + "\n")
                                        fq2_output.write(tu[1])
                                if a % 4 == 3:
                                        fq1_output.write(tu[0])
                                        fq2_output.write(tu[1])
                                if a % 4 == 0:
                                        fq1_output.write(tu[0])
                                        fq2_output.write(tu[1])

rule bismark_alignment:
    input:  R1 = '{sample}/Mid-files/02_FqWithUmiMeth_1.fq.gz',
            R2 = '{sample}/Mid-files/02_FqWithUmiMeth_2.fq.gz',
    output: bam = temp('{sample}/Mid-files/03_bismark_pe.bam')
    log:    stdout = '{sample}/logs/3_bismark_alignment.stdout',
            stderr = '{sample}/logs/3_bismark_alignment.stderr'
    params: bismark = config['bismark']['path'],
            genome = config['bismark']['genome'],
    threads:config['bismark']['threads']
    conda:  'samtools'
    shell:
            '{params.bismark} -1 {input.R1} -2 {input.R2} '
            '-B {wildcards.sample}/Mid-files/03_bismark '
            '--genome {params.genome} '
            '--temp_dir {wildcards.sample}/Mid-files '
            '--non_directional '
            '-p {threads} --local '
            '1> {log.stdout} 2> {log.stderr}'

rule bam_dedup:
    input:  bam = '{sample}/Mid-files/03_bismark_pe.bam'
    output: dedup = temp('{sample}/Mid-files/05.deduplicated.bam')
    params: dedup_bismark = config['deduplicate_bismark']['path'],
    log:    stdout = '{sample}/logs/5_bismark_dedup.stdout',
            stderr = '{sample}/logs/5_bismark_dedup.stderr'
    conda:  'samtools'
    shell:
            '{params.dedup_bismark} {input.bam} '
            '-o 05 --output_dir {wildcards.sample}/Mid-files --barcode '
            '1> {log.stdout} 2> {log.stderr}'

rule samtools_sort:
    input:  bam = '{sample}/Mid-files/03_bismark_pe.bam',
            dedup = '{sample}/Mid-files/05.deduplicated.bam'
    output: bam = '{sample}/Mid-files/03_bismark_sort.bam',
            dedup = '{sample}/Mid-files/05_deduplicated_sort.bam'
    log:    stdout = '{sample}/logs/5_samtools_sort.stdout',
            stderr = '{sample}/logs/5_samtools_sort.stderr'
    params: samtools = config['samtools']['path']
    threads:config['samtools']['threads']
    shell:
            '{params.samtools} view -bh -f 3 -q 10 '
            '-@ {threads} {input.bam} |{params.samtools} '
            'sort - -@ {threads} -o {output.bam}\n'
            '{params.samtools} view -bh -f 3 -q 10 '
            '-@ {threads} {input.dedup} |{params.samtools} '
            'sort - -@ {threads} -o {output.dedup}\n'
            '{params.samtools} index -@ {threads} {output.bam}\n'
            '{params.samtools} index -@ {threads} {output.dedup}'

rule indicator_stat:
    input:  cnv = '{sample}/Mid-files/05_deduplicated_sort.bam'
    output: stat = '{sample}/{sample}_basic_summary.xls'
    params: primer_bed = config['bed'],
            script = config['scripts'],
            python3 = config['python3'],
    threads:config['samtools']['threads']
    log:    stdout = '{sample}/logs/5_stat.stdout',
    shell:
            '{params.python3} {params.script}/read_summary_methylation.py '
            '-bed {params.primer_bed} --fq-prefix {wildcards.sample} '
            '-outdir {wildcards.sample}/Mid-files 1> {log.stdout}'
